// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MESHDATAFBX_H_
#define FLATBUFFERS_GENERATED_MESHDATAFBX_H_

#include "flatbuffers/flatbuffers.h"

struct Vec2;

struct Vec3;

struct Vec4;

struct Mat_Meta;

struct Vertex_Meta;
struct Vertex_MetaBuilder;

struct OneNodeData_Meta;
struct OneNodeData_MetaBuilder;

struct Index_Meta;
struct Index_MetaBuilder;

struct Bone_Meta;
struct Bone_MetaBuilder;

struct Material_Meta;
struct Material_MetaBuilder;

struct AnimationData_Meta;
struct AnimationData_MetaBuilder;

struct OneFrameList_Meta;
struct OneFrameList_MetaBuilder;

struct MeshData_Meta;
struct MeshData_MetaBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vec2() {
    memset(static_cast<void *>(this), 0, sizeof(Vec2));
  }
  Vec2(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Vec2, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3() {
    memset(static_cast<void *>(this), 0, sizeof(Vec3));
  }
  Vec3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vec3, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec4 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  Vec4() {
    memset(static_cast<void *>(this), 0, sizeof(Vec4));
  }
  Vec4(float _x, float _y, float _z, float _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(Vec4, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Mat_Meta FLATBUFFERS_FINAL_CLASS {
 private:
  float _m1_1_;
  float _m1_2_;
  float _m1_3_;
  float _m1_4_;
  float _m2_1_;
  float _m2_2_;
  float _m2_3_;
  float _m2_4_;
  float _m3_1_;
  float _m3_2_;
  float _m3_3_;
  float _m3_4_;
  float _m4_1_;
  float _m4_2_;
  float _m4_3_;
  float _m4_4_;

 public:
  Mat_Meta() {
    memset(static_cast<void *>(this), 0, sizeof(Mat_Meta));
  }
  Mat_Meta(float __m1_1, float __m1_2, float __m1_3, float __m1_4, float __m2_1, float __m2_2, float __m2_3, float __m2_4, float __m3_1, float __m3_2, float __m3_3, float __m3_4, float __m4_1, float __m4_2, float __m4_3, float __m4_4)
      : _m1_1_(flatbuffers::EndianScalar(__m1_1)),
        _m1_2_(flatbuffers::EndianScalar(__m1_2)),
        _m1_3_(flatbuffers::EndianScalar(__m1_3)),
        _m1_4_(flatbuffers::EndianScalar(__m1_4)),
        _m2_1_(flatbuffers::EndianScalar(__m2_1)),
        _m2_2_(flatbuffers::EndianScalar(__m2_2)),
        _m2_3_(flatbuffers::EndianScalar(__m2_3)),
        _m2_4_(flatbuffers::EndianScalar(__m2_4)),
        _m3_1_(flatbuffers::EndianScalar(__m3_1)),
        _m3_2_(flatbuffers::EndianScalar(__m3_2)),
        _m3_3_(flatbuffers::EndianScalar(__m3_3)),
        _m3_4_(flatbuffers::EndianScalar(__m3_4)),
        _m4_1_(flatbuffers::EndianScalar(__m4_1)),
        _m4_2_(flatbuffers::EndianScalar(__m4_2)),
        _m4_3_(flatbuffers::EndianScalar(__m4_3)),
        _m4_4_(flatbuffers::EndianScalar(__m4_4)) {
  }
  float _m1_1() const {
    return flatbuffers::EndianScalar(_m1_1_);
  }
  float _m1_2() const {
    return flatbuffers::EndianScalar(_m1_2_);
  }
  float _m1_3() const {
    return flatbuffers::EndianScalar(_m1_3_);
  }
  float _m1_4() const {
    return flatbuffers::EndianScalar(_m1_4_);
  }
  float _m2_1() const {
    return flatbuffers::EndianScalar(_m2_1_);
  }
  float _m2_2() const {
    return flatbuffers::EndianScalar(_m2_2_);
  }
  float _m2_3() const {
    return flatbuffers::EndianScalar(_m2_3_);
  }
  float _m2_4() const {
    return flatbuffers::EndianScalar(_m2_4_);
  }
  float _m3_1() const {
    return flatbuffers::EndianScalar(_m3_1_);
  }
  float _m3_2() const {
    return flatbuffers::EndianScalar(_m3_2_);
  }
  float _m3_3() const {
    return flatbuffers::EndianScalar(_m3_3_);
  }
  float _m3_4() const {
    return flatbuffers::EndianScalar(_m3_4_);
  }
  float _m4_1() const {
    return flatbuffers::EndianScalar(_m4_1_);
  }
  float _m4_2() const {
    return flatbuffers::EndianScalar(_m4_2_);
  }
  float _m4_3() const {
    return flatbuffers::EndianScalar(_m4_3_);
  }
  float _m4_4() const {
    return flatbuffers::EndianScalar(_m4_4_);
  }
};
FLATBUFFERS_STRUCT_END(Mat_Meta, 64);

struct Vertex_Meta FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Vertex_MetaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POS = 4,
    VT_BONEWEIGHT = 6,
    VT_BONEINDEX = 8,
    VT_NORMAL = 10,
    VT_BINORMAL = 12,
    VT_TANGENT = 14,
    VT_UV = 16
  };
  const Vec4 *Pos() const {
    return GetStruct<const Vec4 *>(VT_POS);
  }
  const Vec4 *BoneWeight() const {
    return GetStruct<const Vec4 *>(VT_BONEWEIGHT);
  }
  const Vec4 *BoneIndex() const {
    return GetStruct<const Vec4 *>(VT_BONEINDEX);
  }
  const Vec3 *Normal() const {
    return GetStruct<const Vec3 *>(VT_NORMAL);
  }
  const Vec3 *BiNormal() const {
    return GetStruct<const Vec3 *>(VT_BINORMAL);
  }
  const Vec3 *Tangent() const {
    return GetStruct<const Vec3 *>(VT_TANGENT);
  }
  const Vec2 *UV() const {
    return GetStruct<const Vec2 *>(VT_UV);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vec4>(verifier, VT_POS) &&
           VerifyField<Vec4>(verifier, VT_BONEWEIGHT) &&
           VerifyField<Vec4>(verifier, VT_BONEINDEX) &&
           VerifyField<Vec3>(verifier, VT_NORMAL) &&
           VerifyField<Vec3>(verifier, VT_BINORMAL) &&
           VerifyField<Vec3>(verifier, VT_TANGENT) &&
           VerifyField<Vec2>(verifier, VT_UV) &&
           verifier.EndTable();
  }
};

struct Vertex_MetaBuilder {
  typedef Vertex_Meta Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Pos(const Vec4 *Pos) {
    fbb_.AddStruct(Vertex_Meta::VT_POS, Pos);
  }
  void add_BoneWeight(const Vec4 *BoneWeight) {
    fbb_.AddStruct(Vertex_Meta::VT_BONEWEIGHT, BoneWeight);
  }
  void add_BoneIndex(const Vec4 *BoneIndex) {
    fbb_.AddStruct(Vertex_Meta::VT_BONEINDEX, BoneIndex);
  }
  void add_Normal(const Vec3 *Normal) {
    fbb_.AddStruct(Vertex_Meta::VT_NORMAL, Normal);
  }
  void add_BiNormal(const Vec3 *BiNormal) {
    fbb_.AddStruct(Vertex_Meta::VT_BINORMAL, BiNormal);
  }
  void add_Tangent(const Vec3 *Tangent) {
    fbb_.AddStruct(Vertex_Meta::VT_TANGENT, Tangent);
  }
  void add_UV(const Vec2 *UV) {
    fbb_.AddStruct(Vertex_Meta::VT_UV, UV);
  }
  explicit Vertex_MetaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Vertex_MetaBuilder &operator=(const Vertex_MetaBuilder &);
  flatbuffers::Offset<Vertex_Meta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Vertex_Meta>(end);
    return o;
  }
};

inline flatbuffers::Offset<Vertex_Meta> CreateVertex_Meta(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Vec4 *Pos = 0,
    const Vec4 *BoneWeight = 0,
    const Vec4 *BoneIndex = 0,
    const Vec3 *Normal = 0,
    const Vec3 *BiNormal = 0,
    const Vec3 *Tangent = 0,
    const Vec2 *UV = 0) {
  Vertex_MetaBuilder builder_(_fbb);
  builder_.add_UV(UV);
  builder_.add_Tangent(Tangent);
  builder_.add_BiNormal(BiNormal);
  builder_.add_Normal(Normal);
  builder_.add_BoneIndex(BoneIndex);
  builder_.add_BoneWeight(BoneWeight);
  builder_.add_Pos(Pos);
  return builder_.Finish();
}

struct OneNodeData_Meta FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OneNodeData_MetaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODENAME = 4,
    VT_WORLDTM = 6,
    VT_GLOBALBINDPOS = 8,
    VT_BINDING = 10,
    VT_TEXON = 12,
    VT_NORMALON = 14,
    VT_MASKON = 16,
    VT_TEXCOUNT = 18,
    VT_NORMALCOUNT = 20,
    VT_MASKMAPCOUNT = 22,
    VT_POLYGONCOUNT = 24,
    VT_VERTEXCOUNT = 26,
    VT_INDEXCOUNT = 28
  };
  const flatbuffers::String *Nodename() const {
    return GetPointer<const flatbuffers::String *>(VT_NODENAME);
  }
  const Mat_Meta *WorldTm() const {
    return GetStruct<const Mat_Meta *>(VT_WORLDTM);
  }
  const Mat_Meta *GlobalbindPos() const {
    return GetStruct<const Mat_Meta *>(VT_GLOBALBINDPOS);
  }
  bool Binding() const {
    return GetField<uint8_t>(VT_BINDING, 0) != 0;
  }
  bool Texon() const {
    return GetField<uint8_t>(VT_TEXON, 0) != 0;
  }
  bool NormalOn() const {
    return GetField<uint8_t>(VT_NORMALON, 0) != 0;
  }
  bool Maskon() const {
    return GetField<uint8_t>(VT_MASKON, 0) != 0;
  }
  int32_t TexCount() const {
    return GetField<int32_t>(VT_TEXCOUNT, 0);
  }
  int32_t NormalCount() const {
    return GetField<int32_t>(VT_NORMALCOUNT, 0);
  }
  int32_t MaskmapCount() const {
    return GetField<int32_t>(VT_MASKMAPCOUNT, 0);
  }
  int32_t PolygonCount() const {
    return GetField<int32_t>(VT_POLYGONCOUNT, 0);
  }
  int32_t VertexCount() const {
    return GetField<int32_t>(VT_VERTEXCOUNT, 0);
  }
  int32_t IndexCount() const {
    return GetField<int32_t>(VT_INDEXCOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NODENAME) &&
           verifier.VerifyString(Nodename()) &&
           VerifyField<Mat_Meta>(verifier, VT_WORLDTM) &&
           VerifyField<Mat_Meta>(verifier, VT_GLOBALBINDPOS) &&
           VerifyField<uint8_t>(verifier, VT_BINDING) &&
           VerifyField<uint8_t>(verifier, VT_TEXON) &&
           VerifyField<uint8_t>(verifier, VT_NORMALON) &&
           VerifyField<uint8_t>(verifier, VT_MASKON) &&
           VerifyField<int32_t>(verifier, VT_TEXCOUNT) &&
           VerifyField<int32_t>(verifier, VT_NORMALCOUNT) &&
           VerifyField<int32_t>(verifier, VT_MASKMAPCOUNT) &&
           VerifyField<int32_t>(verifier, VT_POLYGONCOUNT) &&
           VerifyField<int32_t>(verifier, VT_VERTEXCOUNT) &&
           VerifyField<int32_t>(verifier, VT_INDEXCOUNT) &&
           verifier.EndTable();
  }
};

struct OneNodeData_MetaBuilder {
  typedef OneNodeData_Meta Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Nodename(flatbuffers::Offset<flatbuffers::String> Nodename) {
    fbb_.AddOffset(OneNodeData_Meta::VT_NODENAME, Nodename);
  }
  void add_WorldTm(const Mat_Meta *WorldTm) {
    fbb_.AddStruct(OneNodeData_Meta::VT_WORLDTM, WorldTm);
  }
  void add_GlobalbindPos(const Mat_Meta *GlobalbindPos) {
    fbb_.AddStruct(OneNodeData_Meta::VT_GLOBALBINDPOS, GlobalbindPos);
  }
  void add_Binding(bool Binding) {
    fbb_.AddElement<uint8_t>(OneNodeData_Meta::VT_BINDING, static_cast<uint8_t>(Binding), 0);
  }
  void add_Texon(bool Texon) {
    fbb_.AddElement<uint8_t>(OneNodeData_Meta::VT_TEXON, static_cast<uint8_t>(Texon), 0);
  }
  void add_NormalOn(bool NormalOn) {
    fbb_.AddElement<uint8_t>(OneNodeData_Meta::VT_NORMALON, static_cast<uint8_t>(NormalOn), 0);
  }
  void add_Maskon(bool Maskon) {
    fbb_.AddElement<uint8_t>(OneNodeData_Meta::VT_MASKON, static_cast<uint8_t>(Maskon), 0);
  }
  void add_TexCount(int32_t TexCount) {
    fbb_.AddElement<int32_t>(OneNodeData_Meta::VT_TEXCOUNT, TexCount, 0);
  }
  void add_NormalCount(int32_t NormalCount) {
    fbb_.AddElement<int32_t>(OneNodeData_Meta::VT_NORMALCOUNT, NormalCount, 0);
  }
  void add_MaskmapCount(int32_t MaskmapCount) {
    fbb_.AddElement<int32_t>(OneNodeData_Meta::VT_MASKMAPCOUNT, MaskmapCount, 0);
  }
  void add_PolygonCount(int32_t PolygonCount) {
    fbb_.AddElement<int32_t>(OneNodeData_Meta::VT_POLYGONCOUNT, PolygonCount, 0);
  }
  void add_VertexCount(int32_t VertexCount) {
    fbb_.AddElement<int32_t>(OneNodeData_Meta::VT_VERTEXCOUNT, VertexCount, 0);
  }
  void add_IndexCount(int32_t IndexCount) {
    fbb_.AddElement<int32_t>(OneNodeData_Meta::VT_INDEXCOUNT, IndexCount, 0);
  }
  explicit OneNodeData_MetaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OneNodeData_MetaBuilder &operator=(const OneNodeData_MetaBuilder &);
  flatbuffers::Offset<OneNodeData_Meta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OneNodeData_Meta>(end);
    return o;
  }
};

inline flatbuffers::Offset<OneNodeData_Meta> CreateOneNodeData_Meta(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> Nodename = 0,
    const Mat_Meta *WorldTm = 0,
    const Mat_Meta *GlobalbindPos = 0,
    bool Binding = false,
    bool Texon = false,
    bool NormalOn = false,
    bool Maskon = false,
    int32_t TexCount = 0,
    int32_t NormalCount = 0,
    int32_t MaskmapCount = 0,
    int32_t PolygonCount = 0,
    int32_t VertexCount = 0,
    int32_t IndexCount = 0) {
  OneNodeData_MetaBuilder builder_(_fbb);
  builder_.add_IndexCount(IndexCount);
  builder_.add_VertexCount(VertexCount);
  builder_.add_PolygonCount(PolygonCount);
  builder_.add_MaskmapCount(MaskmapCount);
  builder_.add_NormalCount(NormalCount);
  builder_.add_TexCount(TexCount);
  builder_.add_GlobalbindPos(GlobalbindPos);
  builder_.add_WorldTm(WorldTm);
  builder_.add_Nodename(Nodename);
  builder_.add_Maskon(Maskon);
  builder_.add_NormalOn(NormalOn);
  builder_.add_Texon(Texon);
  builder_.add_Binding(Binding);
  return builder_.Finish();
}

inline flatbuffers::Offset<OneNodeData_Meta> CreateOneNodeData_MetaDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *Nodename = nullptr,
    const Mat_Meta *WorldTm = 0,
    const Mat_Meta *GlobalbindPos = 0,
    bool Binding = false,
    bool Texon = false,
    bool NormalOn = false,
    bool Maskon = false,
    int32_t TexCount = 0,
    int32_t NormalCount = 0,
    int32_t MaskmapCount = 0,
    int32_t PolygonCount = 0,
    int32_t VertexCount = 0,
    int32_t IndexCount = 0) {
  auto Nodename__ = Nodename ? _fbb.CreateString(Nodename) : 0;
  return CreateOneNodeData_Meta(
      _fbb,
      Nodename__,
      WorldTm,
      GlobalbindPos,
      Binding,
      Texon,
      NormalOn,
      Maskon,
      TexCount,
      NormalCount,
      MaskmapCount,
      PolygonCount,
      VertexCount,
      IndexCount);
}

struct Index_Meta FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Index_MetaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX_A = 4,
    VT_INDEX_B = 6,
    VT_INDEX_C = 8
  };
  int64_t index_A() const {
    return GetField<int64_t>(VT_INDEX_A, 0);
  }
  int64_t index_B() const {
    return GetField<int64_t>(VT_INDEX_B, 0);
  }
  int64_t index_C() const {
    return GetField<int64_t>(VT_INDEX_C, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_INDEX_A) &&
           VerifyField<int64_t>(verifier, VT_INDEX_B) &&
           VerifyField<int64_t>(verifier, VT_INDEX_C) &&
           verifier.EndTable();
  }
};

struct Index_MetaBuilder {
  typedef Index_Meta Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_index_A(int64_t index_A) {
    fbb_.AddElement<int64_t>(Index_Meta::VT_INDEX_A, index_A, 0);
  }
  void add_index_B(int64_t index_B) {
    fbb_.AddElement<int64_t>(Index_Meta::VT_INDEX_B, index_B, 0);
  }
  void add_index_C(int64_t index_C) {
    fbb_.AddElement<int64_t>(Index_Meta::VT_INDEX_C, index_C, 0);
  }
  explicit Index_MetaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Index_MetaBuilder &operator=(const Index_MetaBuilder &);
  flatbuffers::Offset<Index_Meta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Index_Meta>(end);
    return o;
  }
};

inline flatbuffers::Offset<Index_Meta> CreateIndex_Meta(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t index_A = 0,
    int64_t index_B = 0,
    int64_t index_C = 0) {
  Index_MetaBuilder builder_(_fbb);
  builder_.add_index_C(index_C);
  builder_.add_index_B(index_B);
  builder_.add_index_A(index_A);
  return builder_.Finish();
}

struct Bone_Meta FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Bone_MetaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_PARENTNAME = 6,
    VT_BONEINDEX = 8,
    VT_LOCALTM = 10,
    VT_GLOBALTM = 12,
    VT_GLOBALBINDINGTM = 14
  };
  const flatbuffers::String *Name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *ParentName() const {
    return GetPointer<const flatbuffers::String *>(VT_PARENTNAME);
  }
  int32_t BoneIndex() const {
    return GetField<int32_t>(VT_BONEINDEX, 0);
  }
  const Mat_Meta *LocalTM() const {
    return GetStruct<const Mat_Meta *>(VT_LOCALTM);
  }
  const Mat_Meta *GlobalTM() const {
    return GetStruct<const Mat_Meta *>(VT_GLOBALTM);
  }
  const Mat_Meta *GlobalBindingTM() const {
    return GetStruct<const Mat_Meta *>(VT_GLOBALBINDINGTM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(Name()) &&
           VerifyOffset(verifier, VT_PARENTNAME) &&
           verifier.VerifyString(ParentName()) &&
           VerifyField<int32_t>(verifier, VT_BONEINDEX) &&
           VerifyField<Mat_Meta>(verifier, VT_LOCALTM) &&
           VerifyField<Mat_Meta>(verifier, VT_GLOBALTM) &&
           VerifyField<Mat_Meta>(verifier, VT_GLOBALBINDINGTM) &&
           verifier.EndTable();
  }
};

struct Bone_MetaBuilder {
  typedef Bone_Meta Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Name(flatbuffers::Offset<flatbuffers::String> Name) {
    fbb_.AddOffset(Bone_Meta::VT_NAME, Name);
  }
  void add_ParentName(flatbuffers::Offset<flatbuffers::String> ParentName) {
    fbb_.AddOffset(Bone_Meta::VT_PARENTNAME, ParentName);
  }
  void add_BoneIndex(int32_t BoneIndex) {
    fbb_.AddElement<int32_t>(Bone_Meta::VT_BONEINDEX, BoneIndex, 0);
  }
  void add_LocalTM(const Mat_Meta *LocalTM) {
    fbb_.AddStruct(Bone_Meta::VT_LOCALTM, LocalTM);
  }
  void add_GlobalTM(const Mat_Meta *GlobalTM) {
    fbb_.AddStruct(Bone_Meta::VT_GLOBALTM, GlobalTM);
  }
  void add_GlobalBindingTM(const Mat_Meta *GlobalBindingTM) {
    fbb_.AddStruct(Bone_Meta::VT_GLOBALBINDINGTM, GlobalBindingTM);
  }
  explicit Bone_MetaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Bone_MetaBuilder &operator=(const Bone_MetaBuilder &);
  flatbuffers::Offset<Bone_Meta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Bone_Meta>(end);
    return o;
  }
};

inline flatbuffers::Offset<Bone_Meta> CreateBone_Meta(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> Name = 0,
    flatbuffers::Offset<flatbuffers::String> ParentName = 0,
    int32_t BoneIndex = 0,
    const Mat_Meta *LocalTM = 0,
    const Mat_Meta *GlobalTM = 0,
    const Mat_Meta *GlobalBindingTM = 0) {
  Bone_MetaBuilder builder_(_fbb);
  builder_.add_GlobalBindingTM(GlobalBindingTM);
  builder_.add_GlobalTM(GlobalTM);
  builder_.add_LocalTM(LocalTM);
  builder_.add_BoneIndex(BoneIndex);
  builder_.add_ParentName(ParentName);
  builder_.add_Name(Name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Bone_Meta> CreateBone_MetaDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *Name = nullptr,
    const char *ParentName = nullptr,
    int32_t BoneIndex = 0,
    const Mat_Meta *LocalTM = 0,
    const Mat_Meta *GlobalTM = 0,
    const Mat_Meta *GlobalBindingTM = 0) {
  auto Name__ = Name ? _fbb.CreateString(Name) : 0;
  auto ParentName__ = ParentName ? _fbb.CreateString(ParentName) : 0;
  return CreateBone_Meta(
      _fbb,
      Name__,
      ParentName__,
      BoneIndex,
      LocalTM,
      GlobalTM,
      GlobalBindingTM);
}

struct Material_Meta FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Material_MetaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIFFUSE = 4,
    VT_AMBIENT = 6,
    VT_SPECULAR = 8,
    VT_MATNUM = 10
  };
  const Vec4 *Diffuse() const {
    return GetStruct<const Vec4 *>(VT_DIFFUSE);
  }
  const Vec4 *Ambient() const {
    return GetStruct<const Vec4 *>(VT_AMBIENT);
  }
  const Vec4 *Specular() const {
    return GetStruct<const Vec4 *>(VT_SPECULAR);
  }
  int32_t MatNum() const {
    return GetField<int32_t>(VT_MATNUM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vec4>(verifier, VT_DIFFUSE) &&
           VerifyField<Vec4>(verifier, VT_AMBIENT) &&
           VerifyField<Vec4>(verifier, VT_SPECULAR) &&
           VerifyField<int32_t>(verifier, VT_MATNUM) &&
           verifier.EndTable();
  }
};

struct Material_MetaBuilder {
  typedef Material_Meta Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Diffuse(const Vec4 *Diffuse) {
    fbb_.AddStruct(Material_Meta::VT_DIFFUSE, Diffuse);
  }
  void add_Ambient(const Vec4 *Ambient) {
    fbb_.AddStruct(Material_Meta::VT_AMBIENT, Ambient);
  }
  void add_Specular(const Vec4 *Specular) {
    fbb_.AddStruct(Material_Meta::VT_SPECULAR, Specular);
  }
  void add_MatNum(int32_t MatNum) {
    fbb_.AddElement<int32_t>(Material_Meta::VT_MATNUM, MatNum, 0);
  }
  explicit Material_MetaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Material_MetaBuilder &operator=(const Material_MetaBuilder &);
  flatbuffers::Offset<Material_Meta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Material_Meta>(end);
    return o;
  }
};

inline flatbuffers::Offset<Material_Meta> CreateMaterial_Meta(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Vec4 *Diffuse = 0,
    const Vec4 *Ambient = 0,
    const Vec4 *Specular = 0,
    int32_t MatNum = 0) {
  Material_MetaBuilder builder_(_fbb);
  builder_.add_MatNum(MatNum);
  builder_.add_Specular(Specular);
  builder_.add_Ambient(Ambient);
  builder_.add_Diffuse(Diffuse);
  return builder_.Finish();
}

struct AnimationData_Meta FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AnimationData_MetaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FRAMEPERSECOND = 4,
    VT_TOTALFRAME = 6,
    VT_STARTTIME = 8,
    VT_ENDTIME = 10,
    VT_TOTALTIME = 12,
    VT_NAME = 14,
    VT_BONEOFFSET = 16
  };
  float FramePerSecond() const {
    return GetField<float>(VT_FRAMEPERSECOND, 0.0f);
  }
  int32_t TotalFrame() const {
    return GetField<int32_t>(VT_TOTALFRAME, 0);
  }
  float StartTime() const {
    return GetField<float>(VT_STARTTIME, 0.0f);
  }
  float EndTime() const {
    return GetField<float>(VT_ENDTIME, 0.0f);
  }
  float TotalTime() const {
    return GetField<float>(VT_TOTALTIME, 0.0f);
  }
  const flatbuffers::String *Name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const Mat_Meta *BoneOffSet() const {
    return GetStruct<const Mat_Meta *>(VT_BONEOFFSET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAMEPERSECOND) &&
           VerifyField<int32_t>(verifier, VT_TOTALFRAME) &&
           VerifyField<float>(verifier, VT_STARTTIME) &&
           VerifyField<float>(verifier, VT_ENDTIME) &&
           VerifyField<float>(verifier, VT_TOTALTIME) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(Name()) &&
           VerifyField<Mat_Meta>(verifier, VT_BONEOFFSET) &&
           verifier.EndTable();
  }
};

struct AnimationData_MetaBuilder {
  typedef AnimationData_Meta Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_FramePerSecond(float FramePerSecond) {
    fbb_.AddElement<float>(AnimationData_Meta::VT_FRAMEPERSECOND, FramePerSecond, 0.0f);
  }
  void add_TotalFrame(int32_t TotalFrame) {
    fbb_.AddElement<int32_t>(AnimationData_Meta::VT_TOTALFRAME, TotalFrame, 0);
  }
  void add_StartTime(float StartTime) {
    fbb_.AddElement<float>(AnimationData_Meta::VT_STARTTIME, StartTime, 0.0f);
  }
  void add_EndTime(float EndTime) {
    fbb_.AddElement<float>(AnimationData_Meta::VT_ENDTIME, EndTime, 0.0f);
  }
  void add_TotalTime(float TotalTime) {
    fbb_.AddElement<float>(AnimationData_Meta::VT_TOTALTIME, TotalTime, 0.0f);
  }
  void add_Name(flatbuffers::Offset<flatbuffers::String> Name) {
    fbb_.AddOffset(AnimationData_Meta::VT_NAME, Name);
  }
  void add_BoneOffSet(const Mat_Meta *BoneOffSet) {
    fbb_.AddStruct(AnimationData_Meta::VT_BONEOFFSET, BoneOffSet);
  }
  explicit AnimationData_MetaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimationData_MetaBuilder &operator=(const AnimationData_MetaBuilder &);
  flatbuffers::Offset<AnimationData_Meta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimationData_Meta>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimationData_Meta> CreateAnimationData_Meta(
    flatbuffers::FlatBufferBuilder &_fbb,
    float FramePerSecond = 0.0f,
    int32_t TotalFrame = 0,
    float StartTime = 0.0f,
    float EndTime = 0.0f,
    float TotalTime = 0.0f,
    flatbuffers::Offset<flatbuffers::String> Name = 0,
    const Mat_Meta *BoneOffSet = 0) {
  AnimationData_MetaBuilder builder_(_fbb);
  builder_.add_BoneOffSet(BoneOffSet);
  builder_.add_Name(Name);
  builder_.add_TotalTime(TotalTime);
  builder_.add_EndTime(EndTime);
  builder_.add_StartTime(StartTime);
  builder_.add_TotalFrame(TotalFrame);
  builder_.add_FramePerSecond(FramePerSecond);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimationData_Meta> CreateAnimationData_MetaDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float FramePerSecond = 0.0f,
    int32_t TotalFrame = 0,
    float StartTime = 0.0f,
    float EndTime = 0.0f,
    float TotalTime = 0.0f,
    const char *Name = nullptr,
    const Mat_Meta *BoneOffSet = 0) {
  auto Name__ = Name ? _fbb.CreateString(Name) : 0;
  return CreateAnimationData_Meta(
      _fbb,
      FramePerSecond,
      TotalFrame,
      StartTime,
      EndTime,
      TotalTime,
      Name__,
      BoneOffSet);
}

struct OneFrameList_Meta FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OneFrameList_MetaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_TRANS = 6,
    VT_ROT_QUAT = 8,
    VT_SCALE = 10
  };
  float Time() const {
    return GetField<float>(VT_TIME, 0.0f);
  }
  const Vec3 *Trans() const {
    return GetStruct<const Vec3 *>(VT_TRANS);
  }
  const Vec4 *Rot_Quat() const {
    return GetStruct<const Vec4 *>(VT_ROT_QUAT);
  }
  const Vec3 *Scale() const {
    return GetStruct<const Vec3 *>(VT_SCALE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_TIME) &&
           VerifyField<Vec3>(verifier, VT_TRANS) &&
           VerifyField<Vec4>(verifier, VT_ROT_QUAT) &&
           VerifyField<Vec3>(verifier, VT_SCALE) &&
           verifier.EndTable();
  }
};

struct OneFrameList_MetaBuilder {
  typedef OneFrameList_Meta Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Time(float Time) {
    fbb_.AddElement<float>(OneFrameList_Meta::VT_TIME, Time, 0.0f);
  }
  void add_Trans(const Vec3 *Trans) {
    fbb_.AddStruct(OneFrameList_Meta::VT_TRANS, Trans);
  }
  void add_Rot_Quat(const Vec4 *Rot_Quat) {
    fbb_.AddStruct(OneFrameList_Meta::VT_ROT_QUAT, Rot_Quat);
  }
  void add_Scale(const Vec3 *Scale) {
    fbb_.AddStruct(OneFrameList_Meta::VT_SCALE, Scale);
  }
  explicit OneFrameList_MetaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OneFrameList_MetaBuilder &operator=(const OneFrameList_MetaBuilder &);
  flatbuffers::Offset<OneFrameList_Meta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OneFrameList_Meta>(end);
    return o;
  }
};

inline flatbuffers::Offset<OneFrameList_Meta> CreateOneFrameList_Meta(
    flatbuffers::FlatBufferBuilder &_fbb,
    float Time = 0.0f,
    const Vec3 *Trans = 0,
    const Vec4 *Rot_Quat = 0,
    const Vec3 *Scale = 0) {
  OneFrameList_MetaBuilder builder_(_fbb);
  builder_.add_Scale(Scale);
  builder_.add_Rot_Quat(Rot_Quat);
  builder_.add_Trans(Trans);
  builder_.add_Time(Time);
  return builder_.Finish();
}

struct MeshData_Meta FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MeshData_MetaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERTEX = 4,
    VT_INDEX = 6,
    VT_MATERIAL = 8,
    VT_BONE = 10,
    VT_ANIMATION = 12,
    VT_FRAMELIST = 14,
    VT_ONENODEDATA = 16
  };
  const Vertex_Meta *Vertex() const {
    return GetPointer<const Vertex_Meta *>(VT_VERTEX);
  }
  const Index_Meta *Index() const {
    return GetPointer<const Index_Meta *>(VT_INDEX);
  }
  const Material_Meta *Material() const {
    return GetPointer<const Material_Meta *>(VT_MATERIAL);
  }
  const Bone_Meta *Bone() const {
    return GetPointer<const Bone_Meta *>(VT_BONE);
  }
  const AnimationData_Meta *Animation() const {
    return GetPointer<const AnimationData_Meta *>(VT_ANIMATION);
  }
  const OneFrameList_Meta *Framelist() const {
    return GetPointer<const OneFrameList_Meta *>(VT_FRAMELIST);
  }
  const OneNodeData_Meta *OneNodeData() const {
    return GetPointer<const OneNodeData_Meta *>(VT_ONENODEDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VERTEX) &&
           verifier.VerifyTable(Vertex()) &&
           VerifyOffset(verifier, VT_INDEX) &&
           verifier.VerifyTable(Index()) &&
           VerifyOffset(verifier, VT_MATERIAL) &&
           verifier.VerifyTable(Material()) &&
           VerifyOffset(verifier, VT_BONE) &&
           verifier.VerifyTable(Bone()) &&
           VerifyOffset(verifier, VT_ANIMATION) &&
           verifier.VerifyTable(Animation()) &&
           VerifyOffset(verifier, VT_FRAMELIST) &&
           verifier.VerifyTable(Framelist()) &&
           VerifyOffset(verifier, VT_ONENODEDATA) &&
           verifier.VerifyTable(OneNodeData()) &&
           verifier.EndTable();
  }
};

struct MeshData_MetaBuilder {
  typedef MeshData_Meta Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Vertex(flatbuffers::Offset<Vertex_Meta> Vertex) {
    fbb_.AddOffset(MeshData_Meta::VT_VERTEX, Vertex);
  }
  void add_Index(flatbuffers::Offset<Index_Meta> Index) {
    fbb_.AddOffset(MeshData_Meta::VT_INDEX, Index);
  }
  void add_Material(flatbuffers::Offset<Material_Meta> Material) {
    fbb_.AddOffset(MeshData_Meta::VT_MATERIAL, Material);
  }
  void add_Bone(flatbuffers::Offset<Bone_Meta> Bone) {
    fbb_.AddOffset(MeshData_Meta::VT_BONE, Bone);
  }
  void add_Animation(flatbuffers::Offset<AnimationData_Meta> Animation) {
    fbb_.AddOffset(MeshData_Meta::VT_ANIMATION, Animation);
  }
  void add_Framelist(flatbuffers::Offset<OneFrameList_Meta> Framelist) {
    fbb_.AddOffset(MeshData_Meta::VT_FRAMELIST, Framelist);
  }
  void add_OneNodeData(flatbuffers::Offset<OneNodeData_Meta> OneNodeData) {
    fbb_.AddOffset(MeshData_Meta::VT_ONENODEDATA, OneNodeData);
  }
  explicit MeshData_MetaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MeshData_MetaBuilder &operator=(const MeshData_MetaBuilder &);
  flatbuffers::Offset<MeshData_Meta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MeshData_Meta>(end);
    return o;
  }
};

inline flatbuffers::Offset<MeshData_Meta> CreateMeshData_Meta(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Vertex_Meta> Vertex = 0,
    flatbuffers::Offset<Index_Meta> Index = 0,
    flatbuffers::Offset<Material_Meta> Material = 0,
    flatbuffers::Offset<Bone_Meta> Bone = 0,
    flatbuffers::Offset<AnimationData_Meta> Animation = 0,
    flatbuffers::Offset<OneFrameList_Meta> Framelist = 0,
    flatbuffers::Offset<OneNodeData_Meta> OneNodeData = 0) {
  MeshData_MetaBuilder builder_(_fbb);
  builder_.add_OneNodeData(OneNodeData);
  builder_.add_Framelist(Framelist);
  builder_.add_Animation(Animation);
  builder_.add_Bone(Bone);
  builder_.add_Material(Material);
  builder_.add_Index(Index);
  builder_.add_Vertex(Vertex);
  return builder_.Finish();
}

inline const MeshData_Meta *GetMeshData_Meta(const void *buf) {
  return flatbuffers::GetRoot<MeshData_Meta>(buf);
}

inline const MeshData_Meta *GetSizePrefixedMeshData_Meta(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<MeshData_Meta>(buf);
}

inline bool VerifyMeshData_MetaBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<MeshData_Meta>(nullptr);
}

inline bool VerifySizePrefixedMeshData_MetaBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<MeshData_Meta>(nullptr);
}

inline void FinishMeshData_MetaBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<MeshData_Meta> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMeshData_MetaBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<MeshData_Meta> root) {
  fbb.FinishSizePrefixed(root);
}

#endif  // FLATBUFFERS_GENERATED_MESHDATAFBX_H_
